#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>

void set_random_seed();
int randn(int n);

struct mm_code_maker{

    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }
    
    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }
    
    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
        /// imagine this is implemented...
        /// (once you implement this correctly you can actually
        /// run the program in this source file)
    }
    
    std::vector<int> sequence;
    
    int length;
    int num; 
};

struct mm_solver{
    
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }
    
    /// this member function creates an attempt to find the right code
    /// this version just generates a random attempt
    /// every time it is called
    /// clearly not a very effective implementation!
    void create_attempt(std::vector<int>& attempt){
        for(int i = 0; i < length; i++){
            attempt.push_back(randn(num));
        }
    }
    
    /// this version just doesn't do anything when it's called
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
        
    }
    
    int length;
    int num;
    
};

/// this is an example of main

int main(){
    /// our program uses random features so we need to call the function setting a random seed
    set_random_seed();
    
    int length, num;
    std::cout << "enter length of sequence and number of possible values:" << std::endl;
    std::cin >> length >> num;
   
    mm_solver solver;
    /// we declare an object of type mm_solver
    solver.init(length, num);
    /// we initialise the values for length and num
    
    mm_code_maker maker;
    /// we declare an object of type mm_code_maker
    maker.init(length, num);
    /// we initialise the values for length and num

    maker.generate_sequence();
    /// we generate a random sequence
    
    int black_hits=0, white_hits=0;
    
    int attempts_limit = 5000;
    /// just some number to limit the number of attempts
    
    int attempts = 0;
    
    while((black_hits < length) && (attempts < attempts_limit)){
        std::vector<int> attempt;
        solver.create_attempt(attempt);
        /// the solver creates an attempt
        maker.give_feedback(attempt, black_hits, white_hits);
        /// we ask for feedback for the attempt
        
        /// we print the attempt
        std::cout << "attempt: " << std::endl;
        for(int i = 0; i < attempt.size(); i++){
            std::cout << attempt[i] << " ";
        }
        std::cout << std::endl;
        
        /// we print the feedback
        std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
        
        /// we give the feedback to the solver so that it can learn
        solver.learn(attempt, black_hits, white_hits);
        
        attempts++;
    }
    
    if(black_hits == length){
        std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;        
    }
    else{
        std::cout << "after " << attempts << " attempts still no solution" << std::endl;
    }
    
    std::cout << "the sequence generated by the code maker was:" << std::endl;
    for(int i = 0; i < maker.sequence.size(); i++){
        std::cout << maker.sequence[i] << " ";
    }
    std::cout << std::endl;
    return 0;
}

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}