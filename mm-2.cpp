#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>

void set_random_seed();
int randn(int n);

struct mm_code_maker{

    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }

    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
        /// imagine this is implemented...
    }

    std::vector<int> sequence;

    int length;
    int num;
};

struct mm_solver{

    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    /// this member function creates an attempt to find the right code
    /// this version generates a random attempt, then checks whether
    /// it has already been tried before and was not the right solution
    /// (if that's the case it generates another attempt etc)
    /// this is clearly still far from being a good implementation!
    void create_attempt(std::vector<int>& attempt){
        bool ready = false;
        while(!ready){

            for(int i = 0; i < length; i++){
                attempt.push_back(randn(num));
            }

            bool found = false;
            for(int i = 0; i < not_correct.size() && !found; i++){
                if(attempt == not_correct[i]){
                    found = true;
                }
            }

            if(found){
                /// the following printing can be used for testing purposes in order
                /// to see how much of an improvement this version is on the previous one
                /// std::cout << "this was already attempted, resetting" << std::endl;
                attempt.clear();
            }
            else{
                ready = true;
            }
        }
    }

    /// this version just learns whether an attempt is correct or not
    /// if it is not, it adds it adds it to the list of unsuccessful attempts
    /// this is clearly still far from being a good implementation
    /// the information from black hits and white hits is not really used
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
        if(black_hits != attempt.size()){
            not_correct.push_back(attempt);
        }
    }

    std::vector<std::vector<int> > not_correct;
    
    int length;
    int num;

};

/// the main is the same as in the previous example

int main(){

    set_random_seed();

    int length, num;
    std::cout << "enter length of sequence and number of possible values:" << std::endl;
    std::cin >> length >> num;

    mm_solver solver;
    solver.init(length, num);

    mm_code_maker maker;
    maker.init(length, num);
    maker.generate_sequence();

    int black_hits=0, white_hits=0;
    int attempts_limit = 5000;
    int attempts = 0;
    while((black_hits < length) && (attempts < attempts_limit)){
        std::vector<int> attempt;
        solver.create_attempt(attempt);
        maker.give_feedback(attempt, black_hits, white_hits);
        std::cout << "attempt: " << std::endl;
        for(int i = 0; i < attempt.size(); i++){
            std::cout << attempt[i] << " ";
        }
        std::cout << std::endl;
        std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
        solver.learn(attempt, black_hits, white_hits);
        attempts++;
    }

    if(black_hits == length){
        std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;
    }
    else{
        std::cout << "after " << attempts << " attempts still no solution" << std::endl;
    }
    std::cout << "the sequence generated by the code maker was:" << std::endl;
    for(int i = 0; i < maker.sequence.size(); i++){
        std::cout << maker.sequence[i] << " ";
    }
    std::cout << std::endl;
    return 0;
}

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}
