#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>

/// you can add other headers as needed
/// but only headers from the standard library
/// and not the algorithm header

/// do not use using namespace std

/// functions for random number generation, do not alter the declarations
void set_random_seed();
int randn(int n);
bool check_contain(int n, const std::vector<int>& v);
int check_repeat(const std::vector<int>& v);

/// you can define and use additional functions and structs,
/// add here the declarations for any other functions
/// and/or structs you wish to define and use
/// (the implementation for functions that don't belong to a struct
/// should be added after the main)

/// this is the struct definition for the code maker
/// do not alter the name


struct mm_code_maker{

    /// this member function sets the values for the member data
    /// representing the length of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter this function
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    /// this member function generates a random sequence based
    /// on the length and num parameters stored as member data
    /// do not alter this function
    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }

    /// do not alter the function interface (name, parameter list, void return)
    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
        /// write here your implementation for this function
        /// which takes in input an attempt
        /// and provides feedback in terms of black hits
        /// and white hits (see linked paper)
        std::vector<int> black;
        std::vector<int> white;

        for(int i = 0; i < attempt.size(); i++){
          if(attempt[i] == sequence[i]){
            black_hits++;
            black.push_back(i);
          }
        }


        for(int i = 0; i < attempt.size(); i++){
          for(int j = 0; j < sequence.size(); j++){
            if((attempt[i] == sequence[j]) && (!check_contain(j, black))){
              white.push_back(j); //contains repeated
            }
          }
        }

        /*if(white.size() > 0){
          white_hits++;
          for(int i = 1; i < white.size(); i++){

            bool repeated = false;

            for(int j = 0; j < white.size() && !repeated; j++){
              if((white[i] == white[j]) && (i != j)){ //problem: repeated it self, fixed
                repeated = true;
              }
            }

            if(!repeated){
              white_hits++;
            }

          }
    } */ //problematic
    white_hits = check_repeat(white);

  }

    /// member data holding the sequence generated by generate_sequence
    /// do not alter this
    std::vector<int> sequence;

    /// member data holding the values for length of code and number of symbols
    /// do not alter these
    int length;
    int num;

    /// do not add any other member data,
    /// in particular note that any variables needed for function give_feedback
    /// need to be declared within give_feedback
    /// (they are not member data of the struct)

    /// you may add other member functions if needed
};


/// this is the struct definition for the solver, do not alter the name
struct mm_solver{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter the function interface (name, parameter list, void return)
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
        std::vector<int> tmp;
        for(int i = 0; i < length; i++){
          tmp.push_back(randn(num));
        }
        set.push_back(tmp);

        while(set.size() < pow(num, length)){

          std::vector<int> tmp;
          bool repeated = false;
          for(int i = 0; i < length; i++){
            tmp.push_back(randn(num));
          }

          for(int i = 0; i < set.size() && !repeated; i++){
            if(tmp == set[i]){
              repeated = true;
            }
          }

          if(!repeated){
            set.push_back(tmp);
          }
        }




        /// you can include additional implementation lines here if needed

    }

    /// this member function creates an attempt to find the right code
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void create_attempt(std::vector<int>& attempt){
        /// write your implementation here
    }

    /// this member function acquires the feedback about a certain attempt
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
        /// write your implementation here
    }

    int length;
    int num;
    std::vector<std::vector<int>> set;

    /// you may add other member functions and member data as needed
    /// (keep in mind the distinction between member function variables
    /// and member data of the struct)

};

int main(){
    /// write the code for the main here in order to test your functions
    /// the main is not relevant for this assignment and we will remove it
    /// from the submissions during the marking
    return 0;
}

/// not a great implementation for set_random_seed and for randn;
/// if you are trying to get better results you may want to change
/// the implementation using C++11 features, see for instance
/// https://isocpp.org/files/papers/n3551.pdf
/// but don't change the interface/declaration of the functions

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}

bool check_contain(int n, const std::vector<int>& v){
  bool contain = false;
  for(int i = 0; i < v.size() && !contain; i++){
    if(n == v[i]){
      contain = true;
    }
  }
  return contain;
}

int check_repeat(const std::vector<int>& v){
  std::vector<int> single;

  for(int i = 0; i < v.size(); i++){
    bool repeat = false;
    for(int j = 0; j < single.size() && !repeat; j++){
      if(v[i] == single[j] && i != j){
        repeat = true;
      }
    }
    if(!repeat){
      single.push_back(v[i]);
    }
  }

  return single.size();
}

int num_of_digits(int num){//returns number of digits in an int
  int i = 10, j = 1;
  while(true){
    if(num < i){
      return j;
    }
    i = i * 10;
    j = j + 1;
  }
}

void extract_digits(int num, std::vector<int>& v){ //extract digits from an int into a vector
  int length = num_of_digits(num);
  if(length == 1){
    v.push_back(num);
  }
  else{
    int lsb = num % 10;
    v.push_back(lsb);
    int tmp = lsb;

    for(int i = 100, j = 10; i <= pow(10, length - 1); i = i * 10, j = j * 10){
      v.push_back((num % i - tmp) / j);
      tmp = num % i;
    }

    v.push_back((num - tmp) / pow(10, length - 1));
  }
}

  int pow(int a, int b){
    int n = a;
    for(int i = 1; i < b; i++){
      n = n * a;
    }
    return n;
  }

  std::vector<int> pool_generator(int length, int num, int count){
    //int set_length = pow(num, length);
    std::vector<int> v, tmp;
    //int tmp = count;
    for(int i = 0; i < length; i++){
      v.push_back(0);
    }

    int quotient = count;
    int remainder;
    while(quotient != 0){
      remainder = quotient % num;
      quotient = (int) quotient / num;
      tmp.push_back(remainder);
    }

    for(int i = v.size() - 1, j = 0; j < tmp.size(); i--, j++){
      v[i] = tmp[j];
    }

    return v;
  }







/// add here the implementation for any other functions you wish to define and use
